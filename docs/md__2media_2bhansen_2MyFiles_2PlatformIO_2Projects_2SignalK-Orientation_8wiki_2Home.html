<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SignalK-Orientation: Using the Signal K Orientation Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SignalK-Orientation<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Orientation output in Signal K format for ESP32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Using the Signal K Orientation Library</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md8"></a>This guide supplements information available in the <a href="https://github.com/BjarneBitscrambler/OrientationSensorFusion-ESP/wiki">Orientation Sensor-Fusion library Wiki</a>.</p>
<p>Below are details specific to using the Orientation library with <a href="https://github.com/SignalK">Signal K</a> / <a href="https://github.com/SignalK/SensESP">SensESP</a>.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Magnetic Calibration</h1>
<p>see also the Orientation Sensor-Fusion Library's <a href="https://github.com/BjarneBitscrambler/OrientationSensorFusion-ESP/wiki/Calibration">Calibration wiki</a> and <a href="https://github.com/BjarneBitscrambler/OrientationSensorFusion-ESP/wiki/Magnetic-Calibration">Magnetic Calibration wiki</a></p>
<p>Magnetic Calibration is needed before the sensor's heading is correct. After calibration, one can <b>expect the magnetic heading to be within 2 degrees or better</b> of the actual direction that the X-axis of the sensor is pointing.</p>
<p>When initially programmed, the sensor has a blank internal calibration table. A background magnetic calibration routing runs during regular operation, calculating the best <b>hard- and soft-iron corrections</b> to apply based on recent data samples. Therefore, after initial power-on, move the sensor through a series of rolls, pitches and yaws to cover a wide range of orientations. This will be best done in the same location that the sensor will be used, just prior to permanently mounting it. After enough readings have been collected (takes 30 - 60 seconds when rotating the sensor by hand) then the sensor should be calibrated. The <em>Fit Error</em> and <em>Magnetic Solver</em> parameters (see below) are useful in deciding if the calibration has been successful.</p>
<p>A Magnetic Calibration can be saved using a physical button-press on the ESP32 module. Once saved in non-volatile memory, the same magnetic calibration will be loaded at following power-ups. Saving a calibration used to be possible using the ESP32's web interface, but SensESPv3 altered this ability and I haven't figured out how to re-implement it. A calibration will be valid until the sensor's magnetic environment changes.</p>
<p>The orientation library provides several output parameters that are useful both when you are performing calibration, and also while using the orientation output. To make these parameters available, you need to define the Signal K paths they will output to and then create instances of the value producers. Here's a screenshot showing several of these additional parameters during calibration:</p>
<p><img src="https://user-images.githubusercontent.com/68290965/105610703-dd407080-5d65-11eb-8d0f-07a8e2ef6d7f.png" alt="Signal K Instrument Panel" title="Instruments showing calibration parameters" class="inline"/></p>
<p>The parameters (and the <code>OrientationValType</code> providing them) are:</p><ul>
<li><b>Fit</b> <code>kMagCalFitInUse</code> reports the <em>fit error</em> of the currently in-use calibration. Lower numbers are better: it starts at 100% when uncalibrated, and you should aim for a value less than 3.5%. Note that Signal K displays this value as a ratio (i.e. a number between [0..1]); multiply by 100 to express it in percent.</li>
<li><b>Fit Trial</b> <code>kMagCalFitTrial</code> reports <em>fit error</em> of the next prospective calibration (the fusion algorithm is always exploring whether a better calibration can be developed using the latest readings). It has the same units as Fit, and if a better fit is found that prospective calibration will replace the current calibration. It will only be saved to non-volatile memory if you explicitly do so in the sensor web interface.</li>
<li><b>Solver</b> <code>kMagCalAlgorithmSolver</code> (called <em>Order</em> in the above screenshot) indicates the complexity of the calibration fitting algorithm, and increases as the number of readings used increases. Solver has possible values of 0 (uncalibrated), 4, 7, and 10 (most sophisticated algorithm).</li>
<li><b>Magnetic Inclination</b> <code>kMagInclination</code> is the geomagnetic dip angle in radians below horizontal based on current readings</li>
<li><b>B Field Magnitude</b> <code>kMagFieldMagnitude</code> is the geomagnetic field magnitude of the current calibration. It is provided in uT (average Earth magnetic field is about 50 uT) since sending it in T (Teslas) results in a value so small that the current Instrument panel options display it as 0.00</li>
<li><b>B Field Magnitude Trial</b> <code>kMagFieldMagnitudeTrial</code> is the geomagnetic field magnitude based on current readings</li>
<li><b>Magnetic Noise Covariance</b> <code>kMagNoiseCovariance</code> is the deviation of the current reading from the calibrated geomagnetic sphere. A lower number indicates more confidence in the current readings. If the noise value rises above about 0.0005, it suggests that the magnetic environment is no longer similar to what it was at the time of the most recent calibration.</li>
</ul>
<p>To ensure a good calibration before saving, keep adding data points via manipulation of the sensor until the <b>Fit-Error value drops below 3.5</b> and the <b>Solver value is 10</b>.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Saving Magnetic Calibration</h1>
<p>Once a good calibration is generated, you may want to save it so it will be automatically loaded each time the microcontroller resets or powers on. Two options are available for permanently saving the magnetic calibration:</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Via the Sensor's Web Interface (temporarily unavailable)</h2>
<p>Access the sensor via WiFi and expand (click on) the entries: <b>Configure device</b> -&gt; <b>sensors</b> -&gt; <b><a class="el" href="structAttitude.html">Attitude</a></b> or <b>Heading</b> -&gt; <b>settings</b>. A "*Save Magnetic Cal*" field should appear:</p>
<p><img src="https://user-images.githubusercontent.com/68290965/104827835-26993900-5817-11eb-93da-cf73175d5352.png" alt="Sensor's Web Interface" title="Sensor Web Interface" class="inline"/></p>
<p>Enter the numeral <b>1</b> in the field, and click on <code>Save</code>.</p>
<p>If you wish to erase any stored calibration, enter the number <b>-1</b> instead, and click <code>Save</code>.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Via a Physical Button</h2>
<p>If a momentary switch is connected to a GPIO pin of the microcontroller, and the software is set up to monitor the switch, then <b>pressing the switch will save the magnetic calibration</b>. See <code>/examples/example_main.cpp</code> for enabling a physical button input, while referring to the following explanation.</p>
<p>A digital input pin is read periodically and, if its state changes, the next consumer (<em>debounce transform</em>) is notified. The example sets the switch read interval and debounce period fairly long, as we don't need quick response for this function and this way an accidental quick push on the switch won't cause one to lose an existing calibration. With the example settings, the <b>switch needs to be held just under 500ms</b> before it takes action.</p>
<p>The <em>debounce transform</em> sends its output to a <em>lambda consumer</em> function, which is defined as a call to the orientation library's <code>SaveMagneticCalibration()</code> method. That saves the current magnetic calibration to EEPROM. There's also a <code>debugI()</code> print to the serial stream (unless DEBUG_DISABLED is defined) which indicates the save function has been called. It's a bit hard to pick out from all the other serial traffic, unless one turns the reporting rate for the other sensors way down...</p>
<p>The example code is appropriate for a <b>physical button that grounds a GPIO</b> pin when pushed, so the GPIO has its pull-up resistor enabled. One can use a switch tied to logic high instead, with a pull-down on the GPIO - just adjust the code that configures the digital input.</p>
<p>Bear in mind for good noise immunity and CPU protection of a device to be used in the field, I <b>recommend putting a few passive components on the switch circuit</b>. This is particularly a good idea if the wire length between the CPU and the switch is longer than, say, 10 cm or there's a chance of zapping the switch with static electricity. There's quite a few configurations commonly used for input protection - for example a series resistor between the switch and the GPIO pin of about 1000 Ohms (the pull-up/pull-down resistance for ESP32 pins is 45 kOhm, so 1 kOhm will overcome that nicely), and then an ESD protection diode rated between 3V3 and 5V0 between the GPIO pin and board ground. An alternative is to use a small-value capacitor instead of the ESD diode - a 100 nF cap should be fine, as the RC time constant together with the 1 kOhm resistor will be plenty short.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Deviation Corrections</h1>
<p>Once the magnetic calibration is performed, the sensor should output reasonably accurate <em>Compass Headings</em>. There will be some residual magnetic environmental distortions, and there likely will be mounting or mechanical offsets as well. Collectively, these <b>Deviation</b> errors cause the <em>Compass Heading</em> to differ from the actual <em>Magnetic Heading</em> of the bow of your vessel. Correcting the sensor reading for <em>Deviation</em> will convert the <em>Compass Heading</em> to the <em>Magnetic Heading</em> of the vessel.</p>
<p>One way of determining Deviation is to point your vessel at a selection of targets with known bearings (determined for example via a chartplotter and GPS and the local Magnetic Variation). By recording the difference between the eCompass' reported Magnetic Heading, and the actual known Magnetic bearing for a variety of objects throughout a 360-degree span, you will create a Deviation table. A graphical plot of the deviations against the bearings will show either a constant offset, or more likely, a varying error that changes smoothly through the full circle.</p>
<p>If the Deviation can be approximated as a constant offset, then the easiest way to convert the Compass Heading to a Magnetic Heading is by passing the value through the AngleCorrection transform: </p><div class="fragment"><div class="line">main.cpp [...]</div>
<div class="line">  sensor_heading</div>
<div class="line">        // Correct for mounting offsets - Pi/2 rotation in my case.</div>
<div class="line">        -&gt;connect_to(new AngleCorrection((PI/2.0), 0.0, kConfigPathHeadingOffset))</div>
<div class="line">        -&gt;connect_to(</div>
<div class="line">            new SKOutputNumber(kSKPathHeadingCompass, kConfigPathHeading_SKC))</div>
<div class="line">        //pass to simple deviation transform. Set initial offset to 0.0 radians.</div>
<div class="line">        -&gt;connect_to( new AngleCorrection( 0.0, 0.0, kConfigPathHeadingDev) )     //&lt;&lt;&lt;&lt; Angle Correction transform</div>
<div class="line">        -&gt;connect_to(</div>
<div class="line">            new SKOutputNumber(kSKPathHeadingMagnetic, kConfigPathHeading_SKM));</div>
</div><!-- fragment --><p>If the Deviation value varies significantly over the circle, then a more accurate way of producing the Magnetic Heading is by using the CurveInterpolator transform: </p><div class="fragment"><div class="line">main.cpp:[...]</div>
<div class="line">        //an optional, more complex transform is a CurveInterpolator</div>
<div class="line">        // CurveInterpolator applies deviation corrections</div>
<div class="line">        -&gt;connect_to( new CurveInterpolator( NULL,kConfigPathHeadingDev) )</div>
<div class="line">        // AngleCorrection normalizes to [0..2Pi] range, when CurveInterpolator output &lt; 0 or &gt; 2*Pi</div>
<div class="line">        -&gt;connect_to(new AngleCorrection(0.0, 0.0, &quot;&quot;))</div>
<div class="line">        -&gt;connect_to(</div>
<div class="line">            new SKOutputNumber(kSKPathHeadingMagnetic, kConfigPathHeading_SKM));</div>
</div><!-- fragment --><p> The CurveInterpolator uses pairs of (input,output) values stored in non-volatile memory as a lookup-table to convert incoming values into outgoing values. Linear Interpolation is used for input values that are not explicitly listed in the table. By using a dozen or so value pairs, one can approximate a fairly complex Deviation curve. Entering the (input,output) pairs is easily done using the web-interface to the sensor via the <code>kConfigPathDeviation</code> menu path provided when instantiating the CurveInterpolator.</p>
<p>The web interface looks like this. To enter new input/output pairs, type them into the editing box and click &lt;Save&gt;. Use radians for the units, and follow the JSON format: {"input":inputVal,"output":outputVal},...</p>
<p><img src="https://github.com/user-attachments/assets/a6a22725-1653-477f-bc82-9bc961a1f81b" alt="screenshot of web interface for entering Deviation table" title="Web Interface" class="inline"/></p>
<p>Note that the default SensESP CurveInterpolator code only allows for a maximum of about 11 value pairs (due to limits on the length of the JSON object used by the HTTP GET and PUT methods). If this is too low for your purposes, you can edit the SensESP code (I believe the affected files are <code>http.cpp</code>, <code>configurable.cpp</code>, and <code>curveinterpolator.cpp</code> to allow more pairs.</p>
<p>Manually entering a large set of deviation value pairs can be tedious and error-prone. Instead of using the sensor's web interface, one can export the (input,output) pairs as a <code>.CSV</code> file (since the deviation plot was likely created in a spreadsheet anyway), then process the <code>.CSV</code> file using an AWK script to create a command line that uses <b>curl</b> to transfer the data directly to the sensor. An example command line is: </p><div class="fragment"><div class="line">curl -X PUT -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;samples&quot;:[{&quot;input&quot;:0.0000,&quot;output&quot;:0.0873},{&quot;input&quot;:0.1745,&quot;output&quot;:0.2793},{&quot;input&quot;:0.3491,&quot;output&quot;:0.4800},{&quot;input&quot;:0.5236,&quot;output&quot;:0.7330},{&quot;input&quot;:0.6981,&quot;output&quot;:0.9163}]}&#39; http://192.168.1.10/configuration/sensors/hdg/deviation &gt; result</div>
</div><!-- fragment --><p> where the IP address for this sensor was <em>192.168.1.10</em> and the config path was */configuration/sensors/hdg/deviation* (modify as needed). A sample AWK script for performing the conversion is in this repository's <code>/examples</code> folder.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Relationship of the Axes and Terminology</h1>
<p><b>X,Y,Z axes are orthogonal, in a Right-handed coordinate system</b>. On the <em>Adafruit FXOS8700/FXAS21002</em> sensor PCB, the axes are printed on the top-side silkscreen.</p>
<p>If the sensor is mounted with the X-axis pointing to the bow of the boat and the Y-axis pointing to Port, then Z points up and the following applies:</p><ul>
<li><b>Heading</b> is rotation about the Z-axis. It increases with rotation to starboard.</li>
<li><b>Pitch</b> is rotation about the Y-axis. Positive is when the bow points up.</li>
<li><b>Roll</b> is rotation about the X-axis. Positive is rolling to starboard.</li>
<li><b>Turn-rate</b> is rotation about the Z-axis. Positive is increasing bearing.</li>
<li><b>Roll-rate</b> is rotation about the X-axis. Positive is rolling to starboard.</li>
<li><b>Pitch-rate</b> is rotation about the Y-axis. Positive is bow rising.</li>
<li><b>Acceleration</b> is measured in the direction of the corresponding axis.</li>
</ul>
<p>If the sensor is mounted differently, or you prefer an alternate nomenclature, the <code>Get___()</code> methods in <code>sensor_fusion_class.cpp</code> can be adjusted.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Output to NMEA2000</h1>
<p>Here are some rough notes for getting the orientation data output on a NMEA2000 (N2K) network. </p>
<h2><a class="anchor" id="autotoc_md16"></a>
Signal K Server</h2>
<h3><a class="anchor" id="autotoc_md17"></a>
Install Plugin signalk-to-nmea2000</h3>
<ul>
<li>use menu <code>Appstore -&gt; Available</code> and <code>Appstore -&gt; Installed</code> to locate and install the plugin. A reboot is needed after installation.</li>
<li>use menu <code>Server -&gt; Plugin Config</code> to configure the <em>Signal K to NMEA 2000</em> plugin. Click on <b>Enabled</b>. Scroll down the list of PGNs to locate the ones you want (e.g. <a class="el" href="structAttitude.html">Attitude</a> 127257 and Heading 127250) and click their <b>Enabled</b> checkboxes. Add any optional resend or sources details. Click <code>Submit</code>. </li>
</ul>
<h3><a class="anchor" id="autotoc_md18"></a>
Configure Output</h3>
<ul>
<li>Use menu item <code>Server -&gt; Data Connections</code> and add the <b>N2Knetwork</b> connection.</li>
<li>Click on the <b>Enabled</b> switch. Choose a <em>NMEA 2000 Source</em>: I use the <code>Canbus (canboatjs)</code> drop-down menu entry.</li>
<li>Specify the <em>Interface</em>: I used <code>can0</code>.</li>
<li>Add any optional filters you want.</li>
<li>Click on <code>Apply</code>.</li>
</ul>
<p>Restart` the Signal K server (it doesn't say to do so, but I found changes made in <em>Data Connections</em> don't take effect until the server is restarted.</p>
<p>You should now have a NMEA2000 packet emitted each time the Signal K server receives updated data for the PGN(s) you enabled. If, for example, the ESP sensor is reporting Magnetic Heading every 100 ms then you should see NMEA 2000 packets with PGN 127250 at 10 Hz.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Updating Firmware</h1>
<p>Once you are happy with the performance of your eCompass, you will probably want to securely mount it in a location that is far from magnetic disturbances. This may not be an easy-to-access location, so if you ever wish to update the firmware remember that the ESP devices can be updated via WiFi in addition to the usual USB cable. The command within <em>platformio</em> to do this is: </p><div class="fragment"><div class="line">pio run --target upload --upload-port &lt;your_device&#39;s_IP-address&gt;</div>
</div><!-- fragment --><p> The IP address can be determined from your Signal K server. Assuming you haven't disabled the standard SensESP sensors (one of which is the sensor's IP address), you can use the Signal K Instrument Panel to look at the path <code>&lt;your_device_name&gt;.ipaddr</code></p>
<h1><a class="anchor" id="autotoc_md20"></a>
Performance Testing</h1>
<p>Since heading information is time-sensitive (e.g. if it is being used to overlay a radar plot on a chart), it is important the the Signal K server receive frequent updates and and process them quickly. Many eCompasses operate at an update rate of 10 Hz or faster. With that in mind, I tested the performance of the Orientation sensor for max update rate and latency before readings appear on the NMEA 2000 bus.</p>
<p>Details are in the wiki page [[SignalK-Orientation Performance Testing]] </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 18 2026 13:43:20 for SignalK-Orientation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
